/* 
程式原理與詳細解釋
1. 程式目的
這個程式的主要目標是從 ESP32 微控制器中提取一個 32 位整數形式的晶片 ID，並透過序列監控器顯示相關資訊。ESP32 的真實晶片 ID 是基於其 MAC 位址（48 位，6 個位元組），但由於某些應用場景（例如 switch...case 語句）只能處理 32 位整數，程式通過特定的位運算，提取 MAC 位址的最後 3 個位元組（24 位），並填充成 32 位整數作為替代的晶片 ID。

2. 核心技術與運作原理
MAC 位址：ESP32 的 MAC 位址儲存在其內部 eFuse 記憶體中，是一個 48 位的唯一識別碼，通常格式為 XX:XX:XX:XX:XX:XX（每部分 8 位，共 6 個位元組）。這個位址由製造商燒錄，確保每個晶片獨一無二。
ESP.getEfuseMac()：這個函數返回 ESP32 的 MAC 位址作為一個 64 位整數（uint64_t），但實際上只有低 48 位有效（6 個位元組）。
位運算提取 ID：程式使用位移（>>）和遮罩（& 0xff）操作，從 MAC 位址中提取後三個位元組（位 16 到 47），並透過左移（<<）和位或（|=）將它們組合起來。最終結果是一個 32 位整數（uint32_t），對應 MAC 位址的最後 3 個位元組，前面補 0 填充到 32 位。
3. 程式流程
初始化（setup）：
Serial.begin(9600) 啟動序列通訊，設定與電腦的通訊速率為 9600 bps，準備輸出資料。
主循環（loop）：
計算晶片 ID：
使用 for 迴圈，i 從 0 開始，每次增加 8，運行兩次（i = 0 和 i = 8）。
第一次（i = 0）：提取 MAC 位址的第 5 個位元組（位 40-47 右移 40 位），左移 0 位。
第二次（i = 8）：提取第 4 個位元組（位 32-39 右移 32 位），左移 8 位。
第三次（i = 16，雖然 i < 17 不執行，但邏輯上可推廣到第 3 個位元組）：提取第 3 個位元組（位 24-31 右移 24 位），左移 16 位。
由於 MAC 位址的前 3 個位元組（位 0-23）未使用，結果填充為 0，構成 32 位整數。
輸出資訊：
使用 Serial.printf 顯示晶片型號和修訂版本（例如 "ESP32-D0WDQ6 Rev 1"）。
使用 Serial.printf 顯示核心數量（通常為 2）。
使用 Serial.println 顯示最終的 32 位晶片 ID。
延遲：
delay(3000) 使程式每 3 秒執行一次，防止資料過於頻繁輸出。
4. 數學與位運算細節
假設 MAC 位址的 48 位表示為 0x112233445566（十六進位）：

位 40-47：0x11（第 6 位元組）
位 32-39：0x22（第 5 位元組）
位 24-31：0x33（第 4 位元組）
位 16-23：0x44（第 3 位元組）
位 8-15：0x55（第 2 位元組）
位 0-7：0x66（第 1 位元組）
程式只取後三個位元組（0x443322），並填充為 32 位：

i = 0：(0x112233445566 >> 40) & 0xff = 0x11 << 0 = 0x00000011
i = 8：(0x112233445566 >> 32) & 0xff = 0x22 << 8 = 0x00002200
i = 16：(0x112233445566 >> 24) & 0xff = 0x33 << 16 = 0x00330000
最終 chipId = 0x00332211（32 位整數）。 
*/
